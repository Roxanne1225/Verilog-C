$date
	Sun Sep 15 14:27:03 2019
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module arraySortCheck_control_test $end
$var wire 1 ! sorted $end
$var wire 1 " select_index $end
$var wire 1 # load_input $end
$var wire 1 $ load_index $end
$var wire 1 % inversion_found $end
$var wire 1 & end_of_array $end
$var wire 1 ' done $end
$var reg 5 ( array [4:0] $end
$var reg 1 ) clock $end
$var reg 1 * go $end
$var reg 5 + length [4:0] $end
$var reg 1 , reset $end
$var integer 32 - i [31:0] $end
$scope module circuit $end
$var wire 5 . array [4:0] $end
$var wire 1 ) clk $end
$var wire 1 & end_of_array $end
$var wire 1 % inversion_found $end
$var wire 5 / length [4:0] $end
$var wire 1 , reset $end
$var wire 1 0 zero_length_case $end
$var wire 1 " select_index $end
$var wire 1 # load_input $end
$var wire 1 $ load_index $end
$var wire 5 1 length_minus_1 [4:0] $end
$var wire 32 2 index_alu_in [31:0] $end
$var wire 32 3 b [31:0] $end
$var wire 32 4 array_plus_index_plus_1 [31:0] $end
$var wire 32 5 array_plus_index [31:0] $end
$var wire 32 6 array_alu_in [31:0] $end
$var wire 1 7 a_ne_b_1 $end
$var wire 1 8 a_lt_b_2 $end
$var wire 1 9 a_lt_b_1 $end
$var wire 32 : a [31:0] $end
$var reg 5 ; array_reg [4:0] $end
$var reg 5 < index_reg [4:0] $end
$var reg 5 = length_reg [4:0] $end
$scope module compareElements $end
$var wire 1 7 ne $end
$var wire 1 9 lt $end
$var wire 32 > B [31:0] $end
$var wire 32 ? A [31:0] $end
$upscope $end
$scope module comparelength $end
$var wire 5 @ A [4:0] $end
$var wire 5 A B [4:0] $end
$var wire 1 B ne $end
$var wire 1 8 lt $end
$upscope $end
$scope module rf $end
$var wire 1 ) clock $end
$var wire 32 C internal_rdData [31:0] $end
$var wire 32 D rdData [31:0] $end
$var wire 5 E rdNum [4:0] $end
$var wire 1 F rdWriteEnable $end
$var wire 1 , reset $end
$var wire 32 G rsData [31:0] $end
$var wire 5 H rsNum [4:0] $end
$var wire 32 I rtData [31:0] $end
$var wire 5 J rtNum [4:0] $end
$var integer 32 K i [31:0] $end
$upscope $end
$upscope $end
$scope module control $end
$var wire 1 ) clock $end
$var wire 1 ' done $end
$var wire 1 & end_of_array $end
$var wire 1 * go $end
$var wire 1 % inversion_found $end
$var wire 1 $ load_index $end
$var wire 1 # load_input $end
$var wire 1 , reset $end
$var wire 1 L sCheck_next $end
$var wire 1 M sGarbage_next $end
$var wire 1 N sNotSorted_next $end
$var wire 1 O sReady_next $end
$var wire 1 P sSorted_next $end
$var wire 1 " select_index $end
$var wire 1 ! sorted $end
$var wire 1 Q sSorted $end
$var wire 1 R sReady $end
$var wire 1 S sNotSorted $end
$var wire 1 T sGarbage $end
$var wire 1 U sCheck $end
$scope module fsCheck $end
$var wire 1 ) clk $end
$var wire 1 L d $end
$var wire 1 V enable $end
$var wire 1 W reset $end
$var reg 1 U q $end
$upscope $end
$scope module fsGarbage $end
$var wire 1 ) clk $end
$var wire 1 M d $end
$var wire 1 X enable $end
$var wire 1 Y reset $end
$var reg 1 T q $end
$upscope $end
$scope module fsNotSorted $end
$var wire 1 ) clk $end
$var wire 1 N d $end
$var wire 1 Z enable $end
$var wire 1 [ reset $end
$var reg 1 S q $end
$upscope $end
$scope module fsReady $end
$var wire 1 ) clk $end
$var wire 1 O d $end
$var wire 1 \ enable $end
$var wire 1 ] reset $end
$var reg 1 R q $end
$upscope $end
$scope module fsSorted $end
$var wire 1 ) clk $end
$var wire 1 P d $end
$var wire 1 ^ enable $end
$var wire 1 _ reset $end
$var reg 1 Q q $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
0_
1^
0]
1\
0[
1Z
0Y
1X
0W
1V
xU
xT
xS
xR
xQ
0P
0O
0N
1M
0L
b100000 K
bx J
bx I
bx H
bx G
zF
bz E
bz D
bx C
xB
bx A
bx @
bx ?
bx >
bx =
bx <
bx ;
bx :
x9
x8
x7
b0xxxxx 6
bx 5
bx 4
bx 3
b0xxxxx 2
bx 1
x0
bx /
bx .
bx -
1,
bx +
0*
0)
bx (
x'
x&
x%
x$
x#
x"
x!
$end
#1
b1 J
b0 H
1&
0'
18
1B
b1 4
b0 5
b0 2
b0 <
b0 @
10
b11111 1
b11111 A
b0 =
b0 6
b0 ;
1T
0R
0"
0$
0#
0U
0!
0Q
0S
1)
bz C
#2
0%
07
09
b0 3
b0 >
b0 I
b0 :
b0 ?
b0 G
0)
b100000 -
0,
#3
17
19
b1 3
b1 >
b1 I
1)
#4
1O
0M
0)
1*
b101 +
b101 /
b1011 (
b1011 .
#5
0T
1R
1)
#6
0)
#7
1)
#8
0)
#9
1)
#10
0)
#11
1)
#12
0)
#13
1)
#14
0O
1L
0)
0*
#15
1P
0L
1"
1$
1#
1U
0R
1)
#16
0)
#17
0&
b1101 J
b1100 H
1'
b1 2
b1 <
b1 @
00
b100 1
b100 A
b101 =
b1101 4
b1100 5
b1011 6
b1011 ;
0"
0$
0#
0U
1!
1Q
1)
#18
b1101 3
b1101 >
b1101 I
19
b1100 :
b1100 ?
b1100 G
0)
#19
1)
#20
0)
#21
1)
#22
0)
#23
1)
#24
0)
#25
1)
#26
0)
#27
1)
#28
0)
#29
1)
#30
0)
#31
1)
#32
0)
#33
1)
#34
0)
#35
1)
#36
1O
0P
0)
1*
b10 (
b10 .
#37
1O
0'
1R
0!
0Q
1)
#38
0)
#39
1)
#40
0)
#41
1)
#42
0)
#43
1)
#44
0)
#45
1)
#46
0O
1L
0)
0*
#47
1"
1$
1#
1U
0R
1)
#48
0)
#49
b101 J
b100 H
b10 2
b10 <
b10 @
b101 4
b100 5
b10 6
b10 ;
1)
#50
0L
1N
1%
09
b10 3
b10 >
b10 I
b11 :
b11 ?
b11 G
0)
#51
1'
b110 J
b101 H
1S
0"
0$
0#
0U
b110 4
b101 5
b11 2
b11 <
b11 @
1)
#52
0%
19
b101 3
b101 >
b101 I
17
b10 :
b10 ?
b10 G
0)
#53
1)
#54
0)
#55
1)
#56
0)
#57
1)
#58
0)
#59
1)
#60
0)
#61
1)
#62
0)
#63
1)
#64
0)
#65
1)
#66
0)
#67
1)
#68
0N
1O
0)
1*
b11 +
b11 /
b111 (
b111 .
#69
1O
0'
1R
0S
1)
#70
0)
#71
1)
#72
0)
#73
1)
#74
0)
#75
1)
#76
0)
#77
1)
#78
0O
1L
0)
0*
#79
1"
1$
1#
1U
0R
1)
#80
0)
#81
0L
1P
1&
b1100 J
b1011 H
b100 2
b100 <
b100 @
08
b10 1
b10 A
00
b11 =
b1100 4
b1011 5
b111 6
b111 ;
1)
#82
b1100 3
b1100 >
b1100 I
19
b111 :
b111 ?
b111 G
0)
#83
1'
b1101 J
b1100 H
1!
1Q
0"
0$
0#
0U
b1101 4
b1100 5
b101 2
b101 <
b101 @
1)
#84
b1101 3
b1101 >
b1101 I
17
19
b1100 :
b1100 ?
b1100 G
0)
#85
1)
#86
0)
#87
1)
#88
0)
#89
1)
#90
0)
#91
1)
#92
0)
#93
1)
#94
0)
#95
1)
#96
0)
#97
1)
#98
0)
#99
1)
#100
0)
#101
1)
#102
0)
#103
1)
#104
0)
#105
1)
#106
0)
#107
1)
#108
0)
