$date
	Fri Sep 13 11:16:00 2019
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module reg_writer_test $end
$var wire 5 ! regnum [4:0] $end
$var wire 1 " done $end
$var reg 1 # clock $end
$var reg 32 $ data [31:0] $end
$var reg 1 % direction $end
$var reg 1 & go $end
$var reg 1 ' reset $end
$scope module rf $end
$var wire 1 # clock $end
$var wire 32 ( internal_rdData [31:0] $end
$var wire 32 ) rdData [31:0] $end
$var wire 1 * rdWriteEnable $end
$var wire 1 ' reset $end
$var wire 32 + rsData [31:0] $end
$var wire 5 , rsNum [4:0] $end
$var wire 32 - rtData [31:0] $end
$var wire 5 . rtNum [4:0] $end
$var wire 5 / rdNum [4:0] $end
$var integer 32 0 i [31:0] $end
$upscope $end
$scope module writer $end
$var wire 1 # clock $end
$var wire 1 % direction $end
$var wire 1 " done $end
$var wire 1 & go $end
$var wire 1 ' reset $end
$var wire 1 1 sDone_next $end
$var wire 1 2 sDown1_next $end
$var wire 1 3 sDown2_next $end
$var wire 1 4 sDown3_next $end
$var wire 1 5 sDown4_next $end
$var wire 1 6 sGarbage_next $end
$var wire 1 7 sStart_next $end
$var wire 1 8 sUp1_next $end
$var wire 1 9 sUp2_next $end
$var wire 1 : sUp3_next $end
$var wire 1 ; sUp4_next $end
$var wire 1 < sUp4 $end
$var wire 1 = sUp3 $end
$var wire 1 > sUp2 $end
$var wire 1 ? sUp1 $end
$var wire 1 @ sStart $end
$var wire 1 A sGarbage $end
$var wire 1 B sDown4 $end
$var wire 1 C sDown3 $end
$var wire 1 D sDown2 $end
$var wire 1 E sDown1 $end
$var wire 1 F sDone $end
$var wire 5 G regnum [4:0] $end
$scope module fsDone $end
$var wire 1 # clk $end
$var wire 1 1 d $end
$var wire 1 H enable $end
$var wire 1 ' reset $end
$var reg 1 F q $end
$upscope $end
$scope module fsDown1 $end
$var wire 1 # clk $end
$var wire 1 2 d $end
$var wire 1 I enable $end
$var wire 1 ' reset $end
$var reg 1 E q $end
$upscope $end
$scope module fsDown2 $end
$var wire 1 # clk $end
$var wire 1 3 d $end
$var wire 1 J enable $end
$var wire 1 ' reset $end
$var reg 1 D q $end
$upscope $end
$scope module fsDown3 $end
$var wire 1 # clk $end
$var wire 1 4 d $end
$var wire 1 K enable $end
$var wire 1 ' reset $end
$var reg 1 C q $end
$upscope $end
$scope module fsDown4 $end
$var wire 1 # clk $end
$var wire 1 5 d $end
$var wire 1 L enable $end
$var wire 1 ' reset $end
$var reg 1 B q $end
$upscope $end
$scope module fsGarbage $end
$var wire 1 # clk $end
$var wire 1 6 d $end
$var wire 1 M enable $end
$var wire 1 N reset $end
$var reg 1 A q $end
$upscope $end
$scope module fsStart $end
$var wire 1 # clk $end
$var wire 1 7 d $end
$var wire 1 O enable $end
$var wire 1 ' reset $end
$var reg 1 @ q $end
$upscope $end
$scope module fsUp1 $end
$var wire 1 # clk $end
$var wire 1 8 d $end
$var wire 1 P enable $end
$var wire 1 ' reset $end
$var reg 1 ? q $end
$upscope $end
$scope module fsUp2 $end
$var wire 1 # clk $end
$var wire 1 9 d $end
$var wire 1 Q enable $end
$var wire 1 ' reset $end
$var reg 1 > q $end
$upscope $end
$scope module fsUp3 $end
$var wire 1 # clk $end
$var wire 1 : d $end
$var wire 1 R enable $end
$var wire 1 ' reset $end
$var reg 1 = q $end
$upscope $end
$scope module fsUp4 $end
$var wire 1 # clk $end
$var wire 1 ; d $end
$var wire 1 S enable $end
$var wire 1 ' reset $end
$var reg 1 < q $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
1S
1R
1Q
1P
1O
0N
1M
1L
1K
1J
1I
1H
b0 G
0F
0E
0D
0C
0B
xA
0@
0?
0>
0=
0<
0;
0:
09
08
07
16
05
04
03
02
01
b100000 0
b0 /
bz .
bx -
bz ,
bx +
1*
bx )
bx (
1'
0&
0%
bx $
0#
0"
b0 !
$end
#1
1A
1#
#2
0#
0'
#3
1#
#4
06
17
0#
b110100000000 $
b110100000000 )
1&
#5
b1000 !
b1000 /
b1000 G
0A
1@
1#
b110100000000 (
#6
07
12
0#
b110100000001 $
b110100000001 )
0&
#7
02
b111 !
b111 /
b111 G
13
1E
0@
1#
b110100000001 (
#8
0#
b110100000010 $
b110100000010 )
#9
b110 !
b110 /
b110 G
03
0E
14
1D
1#
b110100000010 (
#10
0#
b110100000011 $
b110100000011 )
#11
b101 !
b101 /
b101 G
15
1C
04
0D
1#
b110100000011 (
#12
0#
b110100000100 $
b110100000100 )
#13
b100 !
b100 /
b100 G
11
05
0C
1B
1#
b110100000100 (
#14
0#
b110100000101 $
b110100000101 )
#15
b0 !
b0 /
b0 G
0*
1"
1F
0B
1#
b110100000101 (
#16
0#
#17
1#
#18
0#
#19
1#
#20
0#
#21
1#
#22
01
1*
0"
0F
b100000 0
16
0#
1'
#23
1A
1#
#24
0#
0'
#25
1#
#26
06
17
0#
1%
b110111111111 $
b110111111111 )
1&
#27
b1000 !
b1000 /
b1000 G
1@
0A
1#
b110111111111 (
#28
07
18
0#
b110111111110 $
b110111111110 )
0&
#29
08
b1001 !
b1001 /
b1001 G
0@
19
1?
1#
b110111111110 (
#30
0#
b110111111101 $
b110111111101 )
#31
b1010 !
b1010 /
b1010 G
1:
1>
09
0?
1#
b110111111101 (
#32
0#
b110111111100 $
b110111111100 )
#33
b1011 !
b1011 /
b1011 G
0:
0>
1;
1=
1#
b110111111100 (
#34
0#
b110111111011 $
b110111111011 )
#35
b1100 !
b1100 /
b1100 G
11
1<
0;
0=
1#
b110111111011 (
#36
0#
b110111111010 $
b110111111010 )
#37
b0 !
b0 /
b0 G
0*
0<
1"
1F
1#
b110111111010 (
#38
0#
#39
1#
#40
0#
#41
1#
#42
0#
#43
1#
#44
0#
#45
1#
#46
0#
